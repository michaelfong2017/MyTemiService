/*
 * Copyright 2019 The TensorFlow Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.robocore.secretcamera;

import android.Manifest;
import android.content.Context;
import android.content.pm.PackageManager;
import android.graphics.ImageFormat;
import android.hardware.camera2.CameraAccessException;
import android.hardware.camera2.CameraCaptureSession;
import android.hardware.camera2.CameraDevice;
import android.hardware.camera2.CameraManager;
import android.hardware.camera2.CaptureFailure;
import android.hardware.camera2.CaptureRequest;
import android.media.Image;
import android.media.ImageReader;
import android.os.Handler;
import android.os.HandlerThread;
import android.util.Base64;
import android.util.Log;
import android.util.SparseIntArray;
import android.view.Surface;

import androidx.annotation.NonNull;
import androidx.core.app.ActivityCompat;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

public class CameraService implements ImageReader.OnImageAvailableListener {

    private static final String TAG = CameraService.class.getSimpleName();

    private static CameraService cameraService;

    // Prevent clients from using the constructor
    private CameraService() {
    }
    //Control the accessible (allowed) instances
    public static CameraService getInstance() {
        Log.d(TAG, "getInstance()");
        if (cameraService == null) {
            cameraService = new CameraService();
        }
        return cameraService;
    }
    private static Context context;
    private static CameraManager cameraManager;
    public static void initialize(Context context) {
        CameraService.context = context;
        CameraService.cameraManager = (CameraManager) context.getSystemService(Context.CAMERA_SERVICE);
    }
    public static void clear() {
        cameraService = null;
    }


    private boolean isProcessingFrame = false;

    /**
     * data
     */
    private static byte[] imageBytes;
    public byte[] getImageBytes() {
        return imageBytes;
    }

    /**
     * public functions
     */
    public void setCamera(String cameraID) { // For Temi, "0" for normal camera, "1' for fish eye camera.
        this.cameraID = cameraID;
    }
    private OnImageProcessedListener onImageProcessedListener;
    public void setOnImageProcessedListener(OnImageProcessedListener onImageProcessedListener) {
        this.onImageProcessedListener = onImageProcessedListener;
    }
    public void startSecretCamera () {
        isProcessingFrame = false;

        startBackgroundThread();
        openCamera(720, 480);
    }
    public void closeSecretCamera() {
        closeCamera();
        stopBackgroundThread();
    }





    /** Conversion from screen rotation to JPEG orientation. */
    private static final SparseIntArray ORIENTATIONS = new SparseIntArray();

    static {
        ORIENTATIONS.append(Surface.ROTATION_0, 90);
        ORIENTATIONS.append(Surface.ROTATION_90, 0);
        ORIENTATIONS.append(Surface.ROTATION_180, 270);
        ORIENTATIONS.append(Surface.ROTATION_270, 180);
    }


    /** A {@link Semaphore} to prevent the app from exiting before closing the camera. */
    private final Semaphore cameraOpenCloseLock = new Semaphore(1);


    /** ID of the current {@link CameraDevice}. */
    private String cameraID;

    /** A {@link CameraCaptureSession } for camera preview. */
    private CameraCaptureSession captureSession;
    /** A reference to the opened {@link CameraDevice}. */
    private CameraDevice cameraDevice;
    /** An additional thread for running tasks that shouldn't block the UI. */
    private HandlerThread backgroundThread;
    /** A {@link Handler} for running tasks in the background. */
    private Handler backgroundHandler;
    /** An {@link ImageReader} that handles preview frame capture. */
    private ImageReader previewReader;
    /** {@link CaptureRequest.Builder} for the camera preview */
    private CaptureRequest.Builder previewRequestBuilder;
    /** {@link CaptureRequest} generated by {@link #previewRequestBuilder} */
    private CaptureRequest previewRequest;

    private CameraCaptureSession.CaptureCallback captureCallback = new CameraCaptureSession.CaptureCallback() {
        @Override
        public void onCaptureFailed(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, @NonNull CaptureFailure failure) {
            Log.d(TAG, "onCaptureFailed()");
            super.onCaptureFailed(session, request, failure);
        }
    };

    /** {@link CameraDevice.StateCallback} is called when {@link CameraDevice} changes its state. */
    private final CameraDevice.StateCallback stateCallback =
            new CameraDevice.StateCallback() {
                @Override
                public void onOpened(final CameraDevice cd) {
                    Log.d(TAG, "onOpened");
                    // This method is called when the camera is opened.  We start camera preview here.
                    cameraOpenCloseLock.release();
                    cameraDevice = cd;
                    createCameraPreviewSession();
                }

                @Override
                public void onDisconnected(final CameraDevice cd) {
                    cameraOpenCloseLock.release();
                    cd.close();
                    cameraDevice = null;
                }

                @Override
                public void onError(final CameraDevice cd, final int error) {
                    cameraOpenCloseLock.release();
                    cd.close();
                    cameraDevice = null;
                }
            };


    /** Opens the camera specified by {@link CameraService#cameraID}. */
    private void openCamera(final int width, final int height) {
        try {
            if (!cameraOpenCloseLock.tryAcquire(2500, TimeUnit.MILLISECONDS)) {
                throw new RuntimeException("Time out waiting to lock camera opening.");
            }
            if (ActivityCompat.checkSelfPermission(context, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) {
                // TODO: Consider calling
                //    ActivityCompat#requestPermissions
                // here to request the missing permissions, and then overriding
                //   public void onRequestPermissionsResult(int requestCode, String[] permissions,
                //                                          int[] grantResults)
                // to handle the case where the user grants the permission. See the documentation
                // for ActivityCompat#requestPermissions for more details.
                return;
            }
            cameraManager.openCamera(cameraID, stateCallback, backgroundHandler);
        } catch (final CameraAccessException e) {
            Log.e(TAG, "Exception!");
        } catch (final InterruptedException e) {
            throw new RuntimeException("Interrupted while trying to lock camera opening.", e);
        }
    }


    /** Closes the current {@link CameraDevice}. */
    private void closeCamera() {
        try {
            cameraOpenCloseLock.acquire();
            if (captureSession != null) {
                captureSession.close();
                captureSession = null;
            }
            if (cameraDevice != null) {
                cameraDevice.close();
                cameraDevice = null;
            }
            if (previewReader != null) {
                previewReader.close();
                previewReader = null;
            }
        } catch (final InterruptedException e) {
            throw new RuntimeException("Interrupted while trying to lock camera closing.", e);
        } finally {
            cameraOpenCloseLock.release();
        }
    }

    /** Starts a background thread and its {@link Handler}. */
    private void startBackgroundThread() {
        backgroundThread = new HandlerThread("ImageListener");
        backgroundThread.start();
        backgroundHandler = new Handler(backgroundThread.getLooper());
    }

    /** Stops the background thread and its {@link Handler}. */
    private void stopBackgroundThread() {
        if (backgroundThread == null) {
            return;
        }
        backgroundThread.quitSafely();
        try {
            backgroundThread.join();
            backgroundThread = null;
            backgroundHandler = null;
        } catch (final InterruptedException e) {
            Log.e(TAG, "Exception!");
        }
    }

    /** Creates a new {@link CameraCaptureSession} for camera preview. */
    private void createCameraPreviewSession() {
        try {
            /** Create the reader for the preview frames.
             *
             */
            if (null == cameraDevice) {
                Log.e(TAG, "cameraDevice is null");
                return;
            }
            previewReader = ImageReader.newInstance(720, 480, ImageFormat.YUV_420_888, 2);
            previewReader.setOnImageAvailableListener(this, backgroundHandler);
            previewRequestBuilder = cameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
            previewRequestBuilder.addTarget(previewReader.getSurface());

            final List<Surface> outputSurfaces = new ArrayList<>();
            outputSurfaces.add(previewReader.getSurface());

            // Here, we create a CameraCaptureSession for camera preview.
            cameraDevice.createCaptureSession(
                    outputSurfaces,
                    new CameraCaptureSession.StateCallback() {

                        @Override
                        public void onConfigured(final CameraCaptureSession cameraCaptureSession) {
                            // The camera is already closed
                            if (null == cameraDevice) {
                                return;
                            }

                            // When the session is ready, we start displaying the preview.
                            captureSession = cameraCaptureSession;
                            try {
                                // Auto focus should be continuous for camera preview.
                                previewRequestBuilder.set(
                                        CaptureRequest.CONTROL_AF_MODE,
                                        CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);
                                // Flash is automatically enabled when necessary.
                                previewRequestBuilder.set(
                                        CaptureRequest.CONTROL_AE_MODE, CaptureRequest.CONTROL_AE_MODE_ON_AUTO_FLASH);

                                // Finally, we start displaying the camera preview.
                                previewRequest = previewRequestBuilder.build();
                                captureSession.setRepeatingRequest(
                                        previewRequest, captureCallback, backgroundHandler);
                            } catch (final CameraAccessException e) {
                                Log.e(TAG, "Exception!");
                            }
                        }

                        @Override
                        public void onConfigureFailed(final CameraCaptureSession cameraCaptureSession) {
                        }
                    },
                    null);

        } catch (CameraAccessException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void onImageAvailable(ImageReader reader) {
        Log.d(TAG, "onImageAvailable()");

        /**
         * YUV_420_888 to RGB
         */
        // Get the YUV data

        final Image image = reader.acquireLatestImage();

        if (image == null) {
//            Log.d(TAG, "null image");
            return;
        }
        if (isProcessingFrame == true) {
            image.close();
            return;
        }
        isProcessingFrame = true;

//        Log.d(TAG, "now process frame");

        // Convert YUV to RGB
//        long startTime = System.nanoTime();
        imageBytes = ImageUtil.imageToByteArray(image);
//        long endTime = System.nanoTime();
//        Log.d(TAG, "convert takes "+(endTime-startTime)+" nanoseconds");
//        String encodedImage = Base64.encodeToString(imageBytes, Base64.DEFAULT);
//        Log.d(TAG, "encodedImage: " + encodedImage);
//        byte[] decodedString = Base64.decode(encodedImage, Base64.DEFAULT);
//        Bitmap decodedByte = BitmapFactory.decodeByteArray(decodedString, 0, decodedString.length);
//        Log.d(TAG, "decodedByte: " + decodedByte);

//        Log.d(TAG, "image now close");
        image.close();
        isProcessingFrame = false;

        onImageProcessedListener.onImageProcessed(imageBytes);
    }
}
